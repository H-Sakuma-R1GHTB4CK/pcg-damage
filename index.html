<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Damage Combo Prototype</title>
  <style>
    :root { --bg:#0b0f14; --panel:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#60a5fa; --line:#334155; }
    body { margin:0; font-family: "SF Pro Display", "Segoe UI", "Noto Sans JP", system-ui, -apple-system, sans-serif; background:var(--bg); color:var(--text); }
    header { padding:16px 18px; border-bottom:1px solid var(--line); display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0; font-weight:700; letter-spacing:.01em; }
    header .hint { color:var(--muted); font-size:12px; }

    .wrap { display:grid; grid-template-columns: minmax(300px, 360px) 1fr; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:12px; }
    .panel h2 { font-size:13px; margin:0 0 10px; color:var(--muted); font-weight:700; letter-spacing:.02em; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    input, select, button {
      background:#0f172a; color:var(--text); border:1px solid var(--line); border-radius:10px;
      padding:9px 10px; font-size:13px;
    }
    input { width: 100%; box-sizing:border-box; }
    button { cursor:pointer; transition: border-color .15s ease, background .15s ease; }
    button.primary { border-color:#2563eb; background:#0b1b3d; }
    button.primary:hover { background:#0e234f; }
    button.danger { border-color:#b91c1c; background:#2a0f15; }
    button.danger:hover { background:#3a1117; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; }
    .tab { padding:8px 10px; border-radius:999px; border:1px solid var(--line); background:#0f172a; cursor:pointer; font-size:13px; }
    .tab.active { border-color:#2563eb; background:#0b1b3d; }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .list { display:flex; flex-direction:column; gap:8px; }
    .item { border:1px solid var(--line); border-radius:12px; padding:10px; background:#0f172a; }
    .item .top { display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .pill { font-size:12px; color:var(--muted); }
    .small { font-size:12px; color:var(--muted); }
    .empty { color:var(--muted); font-size:12px; padding:4px 0; }
    .moves { display:flex; gap:8px; flex-wrap:wrap; }
    .moveBtn { position:relative; border-style:dashed; padding:8px 10px 8px 30px; display:flex; align-items:center; gap:8px; }
    .moveBtn:hover { border-color:#64748b; }
    .moveBtn::before {
      content:"";
      position:absolute;
      left:10px;
      top:50%;
      width:14px;
      height:14px;
      transform:translateY(-50%);
      border-radius:4px;
      border:1px solid var(--line);
      background: var(--mvcolor, #888);
      pointer-events:none;
    }
    .colorHit {
      position:absolute;
      left:8px;
      top:50%;
      width:18px;
      height:18px;
      transform:translateY(-50%);
      cursor:pointer;
      background:transparent;
      border:none;
      padding:0;
    }

    /* custom color picker */
    .pickerOverlay {
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
    }
    .pickerCard {
      background:#0f172a;
      border:1px solid var(--line);
      border-radius:12px;
      padding:14px;
      box-shadow:0 20px 40px rgba(0,0,0,0.45);
      width:280px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .pickerSat {
      position:relative;
      height:150px;
      border-radius:10px;
      overflow:hidden;
      cursor:crosshair;
      border:1px solid var(--line);
    }
    .pickerSat::before {
      content:"";
      position:absolute; inset:0;
      background:linear-gradient(to right, #fff, var(--picker-hue, red)), linear-gradient(to top, #000, transparent);
      background-blend-mode: multiply;
    }
    .pickerSatHandle {
      position:absolute;
      width:12px; height:12px;
      border:2px solid #fff;
      border-radius:50%;
      box-shadow:0 0 0 2px #0b0f14;
      transform:translate(-50%, -50%);
      pointer-events:none;
    }
    .pickerHue {
      position:relative;
      height:14px;
      border-radius:8px;
      border:1px solid var(--line);
      background:linear-gradient(to right, red, yellow, lime, cyan, blue, magenta, red);
      cursor:pointer;
    }
    .pickerHueHandle {
      position:absolute;
      top:50%;
      width:12px; height:12px;
      border:2px solid #fff;
      border-radius:50%;
      box-shadow:0 0 0 2px #0b0f14;
      transform:translate(-50%, -50%);
      pointer-events:none;
    }
    .pickerFooter { display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .pickerPreview { width:46px; height:28px; border-radius:8px; border:1px solid var(--line); }
    .groupCard { border:1px solid var(--line); border-radius:12px; padding:10px; background:#0f172a; margin-bottom:10px; }
    .groupHeader { display:flex; align-items:center; gap:8px; margin-bottom:8px; }
    .groupRows { display:flex; flex-direction:column; gap:6px; padding-left:10px; }
    .groupRow { display:flex; justify-content:space-between; align-items:center; border:1px dashed var(--line); border-radius:10px; padding:6px 8px; background:#0b1220; }
    .combos { display:flex; gap:8px; flex-wrap:wrap; }
    .comboCard { min-width: 220px; flex: 1 1 240px; }
    .comboCard.selected { outline:2px solid #2563eb; outline-offset:0; }
    .seg { display:flex; justify-content:space-between; font-size:12px; color:var(--muted); margin-top:6px; }
    .divider { height:1px; background:var(--line); margin:10px 0; }

    /* chart */
    .chartWrap { display:flex; flex-direction:column; gap:10px; }
    .chartHead { display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; color:var(--muted); font-size:12px; }
    .badge { border:1px solid var(--line); border-radius:999px; padding:6px 10px; background:#0f172a; }
    svg { width:100%; height:520px; background:#0b1220; border:1px solid var(--line); border-radius:12px; }
    .axisText { fill:#94a3b8; font-size:11px; }
    .hpLine { stroke-width:1; stroke-dasharray:6 6; opacity:0.95; }
    .hpLabel { font-size:11px; font-weight:700; paint-order: stroke fill; }
    .barStroke { stroke:#0b1220; stroke-width:2; }

    @media (max-width: 899px) {
      header { flex-direction:column; align-items:flex-start; }
      .wrap { grid-template-columns: 1fr; padding:10px; }
      .panel { padding:14px; }
      .grid2 { grid-template-columns: 1fr; }
      .combos { flex-direction:column; }
      .comboCard { width:100%; }
      .chartHead { align-items:flex-start; }
      svg { height:420px; }
    }
  </style>
</head>
<body>
<header>
  <h1>ãƒ€ãƒ¡ãƒ¼ã‚¸çµ„ã¿åˆã‚ã›ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ï¼ˆå¼±ç‚¹ãƒ»æŠµæŠ—åŠ›ãƒ»ç‰¹æ€§ãªã—ï¼‰</h1>
  <div class="hint">æŠ€ã‚’ç™»éŒ² â†’ çµ„ã¿åˆã‚ã›ã‚’è¿½åŠ  â†’ æŠ€ãƒœã‚¿ãƒ³ã§ç©ã¿ä¸Šã’ / ä»®æƒ³æ•µã®HPãƒ©ã‚¤ãƒ³è¿½åŠ </div>
</header>

<div class="wrap">
  <aside class="panel">
    <h2>æ”»æ’ƒã™ã‚‹ãƒã‚±ãƒ¢ãƒ³ï¼ˆãƒšãƒ¼ã‚¸ï¼‰</h2>
    <div class="tabs" id="tabs"></div>

    <div class="divider"></div>

    <div class="row">
      <input id="newAttackerName" placeholder="ä¾‹ï¼šNã®ã‚¾ãƒ­ã‚¢ãƒ¼ã‚¯ex" />
      <button class="primary" id="addAttackerBtn">è¿½åŠ </button>
    </div>

    <div class="divider"></div>

    <h2>æŠ€/ãƒ€ãƒ¡ãƒ¼ã‚¸ç™»éŒ²</h2>
    <div class="grid2">
      <div>
        <div class="small">æŠ€å</div>
        <input id="moveName" placeholder="ä¾‹ï¼šãƒ©ãƒ³ãƒšãƒ¼ã‚¸ã‚µãƒ³ãƒ€ãƒ¼" />
      </div>
      <div>
        <div class="small">ãƒ€ãƒ¡ãƒ¼ã‚¸</div>
        <input id="moveDmg" type="number" min="0" placeholder="250" />
      </div>
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="primary" id="addMoveBtn">ã“ã®ãƒšãƒ¼ã‚¸ã«æŠ€ã‚’è¿½åŠ </button>
    </div>

    <div class="divider"></div>

    <h2>ä»®æƒ³æ•µï¼ˆHPãƒ©ã‚¤ãƒ³ï¼‰</h2>
    <div class="grid2">
      <div>
        <div class="small">åå‰</div>
        <input id="enemyName" placeholder="ä¾‹ï¼šæ‚ªãƒªã‚¶ãƒ¼ãƒ‰ãƒ³ex" />
      </div>
      <div>
        <div class="small">HP</div>
        <input id="enemyHp" type="number" min="0" placeholder="330" />
      </div>
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="primary" id="addEnemyBtn">ä»®æƒ³æ•µã«è¿½åŠ </button>
      <button class="danger" id="clearEnemiesBtn">ä»®æƒ³æ•µã‚’å…¨å‰Šé™¤</button>
    </div>
    <div class="divider"></div>
    <h2>ä»®æƒ³æ•µãƒªã‚¹ãƒˆï¼ˆå€‹åˆ¥å‰Šé™¤ï¼‰</h2>
    <div class="list" id="enemiesList"></div>
  </aside>

  <main class="panel chartWrap">
    <div class="chartHead">
      <div>
        <div class="badge" id="pageTitle">â€”</div>
      </div>
      <div class="row">
        <button class="primary" id="addComboBtn">ãƒ€ãƒ¡ãƒ¼ã‚¸ã®çµ„ã¿åˆã‚ã›ã‚’è¿½åŠ </button>
        <button class="danger" id="deleteComboBtn">é¸æŠä¸­ã®çµ„ã¿åˆã‚ã›ã‚’å‰Šé™¤</button>
      </div>
    </div>

    <div class="legend" id="legend"></div>

    <div class="panel" style="padding:12px;">
      <h2>æŠ€ãƒœã‚¿ãƒ³ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é¸æŠä¸­ã®çµ„ã¿åˆã‚ã›ã¸è¿½åŠ ï¼‰</h2>
      <div class="moves" id="moves"></div>
      <div class="small" style="margin-top:6px;">è‰²ã‚¢ã‚¤ã‚³ãƒ³ã¯å‚ç…§ã®ã¿ã€‚âœï¸ã§ç·¨é›†ã€ğŸ—‘ï¸ã§å‰Šé™¤ã€‚</div>
    </div>

    <div class="panel" style="padding:12px;">
      <h2>çµ„ã¿åˆã‚ã›ãƒªã‚¹ãƒˆï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é¸æŠï¼‰</h2>
      <div class="combos" id="combos"></div>
    </div>

    <div>
      <svg id="chart" viewBox="0 0 900 520" preserveAspectRatio="none"></svg>
      <div class="small" style="margin-top:8px;">
        ç¸¦è»¸ï¼ãƒ€ãƒ¡ãƒ¼ã‚¸ / æ¨ªï¼çµ„ã¿åˆã‚ã›ï¼ˆåˆ—ï¼‰ã€‚ç‚¹ç·šï¼ä»®æƒ³æ•µHPï¼ˆè‰²ã¯å„ä»®æƒ³æ•µã«å¯¾å¿œï¼‰ã€‚
      </div>
    </div>
  </main>
</div>

<script>
  // -------- state --------
  const STORAGE_KEY = "pcg-damage-state-v1";

  function createSampleState() {
    const sampleCombo1 = { id: crypto.randomUUID(), name: "Combo 1", segments: [] };
    const sampleCombo2 = { id: crypto.randomUUID(), name: "Combo 2", segments: [] };
    const attackerId = crypto.randomUUID();
    return {
      attackers: [
        {
          id: attackerId,
          name: "ã‚µãƒ³ãƒ—ãƒ«ï¼šNã®ã‚¾ãƒ­ã‚¢ãƒ¼ã‚¯ex",
          moves: [
            { id: crypto.randomUUID(), name: "ãƒ©ãƒ³ãƒšãƒ¼ã‚¸ã‚µãƒ³ãƒ€ãƒ¼", dmg: 250 },
            { id: crypto.randomUUID(), name: "ã‚¤ãƒã‚»ãƒ³ãƒˆãƒ•ãƒ¬ã‚¤ãƒ ", dmg: 170 },
            { id: crypto.randomUUID(), name: "ã²ãã•ã", dmg: 70 },
            { id: crypto.randomUUID(), name: "è£œæ­£ï¼š+40", dmg: 40 },
            { id: crypto.randomUUID(), name: "è£œæ­£ï¼š+50", dmg: 50 },
          ],
          combos: [sampleCombo1, sampleCombo2],
          selectedComboId: sampleCombo1.id,
          enemies: [
            { id: crypto.randomUUID(), name: "æ‚ªãƒªã‚¶ãƒ¼ãƒ‰ãƒ³ex", hp: 330 },
            { id: crypto.randomUUID(), name: "ãƒ‰ãƒ©ãƒ‘ãƒ«ãƒˆex", hp: 320 }
          ]
        }
      ],
      activeAttackerId: attackerId
    };
  }

  function normalizeState(raw) {
    if (!raw || !Array.isArray(raw.attackers) || raw.attackers.length === 0) {
      return createSampleState();
    }
    const attackers = raw.attackers.map((a, idx) => {
      const combos = (Array.isArray(a.combos) && a.combos.length ? a.combos : [{ id: crypto.randomUUID(), name: "Combo 1", segments: [] }]).map((c, ci) => {
        const segments = Array.isArray(c.segments) ? c.segments.map(s => ({
          moveId: s.moveId || crypto.randomUUID(),
          name: s.name || "è£œæ­£/æŠ€",
          dmg: Number(s.dmg) || 0
        })) : [];
        return {
          id: c.id || crypto.randomUUID(),
          name: c.name || `Combo ${ci + 1}`,
          segments
        };
      });
      return {
        id: a.id || crypto.randomUUID(),
        name: a.name || `æ”»æ’ƒå´ ${idx + 1}`,
        moves: Array.isArray(a.moves) ? a.moves.map((m, mi) => ({
          id: m.id || crypto.randomUUID(),
          name: m.name || `æŠ€ ${mi + 1}`,
          dmg: Number(m.dmg) || 0,
          color: typeof m.color === "string" ? m.color : undefined
        })) : [],
        combos,
        selectedComboId: combos.find(c => c.id === a.selectedComboId)?.id || combos[0].id,
        enemies: Array.isArray(a.enemies) ? a.enemies.map((e, ei) => ({
          id: e.id || crypto.randomUUID(),
          name: e.name || `ä»®æƒ³æ•µ ${ei + 1}`,
          hp: Number(e.hp) || 0,
          color: typeof e.color === "string" ? e.color : undefined
        })) : []
      };
    });

    const activeAttackerId = attackers.find(a => a.id === raw.activeAttackerId)?.id || attackers[0].id;
    return { attackers, activeAttackerId };
  }

  function persistState() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      console.warn("ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ", e);
    }
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      return normalizeState(raw ? JSON.parse(raw) : null);
    } catch (e) {
      console.warn("èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚µãƒ³ãƒ—ãƒ«ã§é–‹å§‹ã—ã¾ã™ã€‚", e);
      return createSampleState();
    }
  }

  let state = loadState();

  // -------- helpers --------
  const $ = (id) => document.getElementById(id);

  function commit() {
    persistState();
    renderAll();
  }

  function getActive() {
    return state.attackers.find(a => a.id === state.activeAttackerId);
  }

  function sumCombo(combo) {
    return combo.segments.reduce((s, seg) => s + seg.dmg, 0);
  }

  function niceMax(val) {
    // round up to nice tick step
    const steps = [50, 100, 150, 200, 250, 300, 400, 500, 600, 800, 1000];
    for (const s of steps) if (val <= s) return s;
    const pow = Math.pow(10, Math.floor(Math.log10(val)));
    return Math.ceil(val / pow) * pow;
  }

  // deterministic-ish color per move id (no libs)
  function hslToHex(h, s, l) {
    s /= 100; l /= 100;
    const f = (n) => {
      const k = (n + h/30) % 12;
      const a = s * Math.min(l, 1 - l);
      const c = l - a * Math.max(-1, Math.min(k - 3, Math.min(9 - k, 1)));
      return Math.round(255 * c);
    };
    const toHex = (v) => v.toString(16).padStart(2, "0");
    return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;
  }
  function colorFor(id) {
    let h = 0;
    for (let i=0;i<id.length;i++) h = (h*31 + id.charCodeAt(i)) >>> 0;
    const hue = h % 360;
    return hslToHex(hue, 60, 42);
  }
  function moveColor(move) {
    return (typeof move.color === "string" && move.color) || colorFor(move.id);
  }
  function enemyColor(enemy) {
    return (typeof enemy.color === "string" && enemy.color) || colorFor(String(enemy.hp));
  }

  function hexToRgb(hex) {
    const m = hex.replace("#", "").match(/.{1,2}/g);
    if (!m) return { r:0, g:0, b:0 };
    const [r,g,b] = m.map(v => parseInt(v, 16));
    return { r, g, b };
  }
  function rgbToHsv(r, g, b) {
    r/=255; g/=255; b/=255;
    const max = Math.max(r,g,b), min = Math.min(r,g,b);
    const d = max - min;
    let h = 0;
    if (d !== 0) {
      if (max === r) h = ((g - b)/d) % 6;
      else if (max === g) h = (b - r)/d + 2;
      else h = (r - g)/d + 4;
      h *= 60; if (h < 0) h += 360;
    }
    const s = max === 0 ? 0 : d / max;
    const v = max;
    return { h, s, v };
  }
  function hsvToHex(h, s, v) {
    const c = v * s;
    const x = c * (1 - Math.abs((h/60)%2 - 1));
    const m = v - c;
    let [r,g,b] = [0,0,0];
    if (0 <= h && h < 60) [r,g,b] = [c,x,0];
    else if (60 <= h && h < 120) [r,g,b] = [x,c,0];
    else if (120 <= h && h < 180) [r,g,b] = [0,c,x];
    else if (180 <= h && h < 240) [r,g,b] = [0,x,c];
    else if (240 <= h && h < 300) [r,g,b] = [x,0,c];
    else [r,g,b] = [c,0,x];
    const toHex = (n) => Math.round((n+m)*255).toString(16).padStart(2,"0");
    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
  }

  // picker UI
  const pickerOverlay = document.createElement("div");
  pickerOverlay.className = "pickerOverlay";
  pickerOverlay.innerHTML = `
    <div class="pickerCard">
      <div class="pickerSat"><div class="pickerSatHandle"></div></div>
      <div class="pickerHue"><div class="pickerHueHandle"></div></div>
      <div class="pickerFooter">
        <div class="pickerPreview"></div>
        <button class="primary" id="pickerClose">é–‰ã˜ã‚‹</button>
      </div>
    </div>
  `;
  document.body.appendChild(pickerOverlay);
  const satEl = pickerOverlay.querySelector(".pickerSat");
  const satHandle = pickerOverlay.querySelector(".pickerSatHandle");
  const hueEl = pickerOverlay.querySelector(".pickerHue");
  const hueHandle = pickerOverlay.querySelector(".pickerHueHandle");
  const previewEl = pickerOverlay.querySelector(".pickerPreview");
  const pickerClose = pickerOverlay.querySelector("#pickerClose");

  let pickerState = { target: null, hsv: { h:0, s:0, v:0 }, dragging: null };

  function applyPickerColor(hex) {
    if (!pickerState.target) return;
    pickerState.target.onPick(hex);
    previewEl.style.background = hex;
    satEl.style.setProperty("--picker-hue", `hsl(${pickerState.hsv.h} 100% 50%)`);
  }

  function openPicker(moveBtn, onPick, currentHex) {
    const { r,g,b } = hexToRgb(currentHex);
    const hsv = rgbToHsv(r,g,b);
    pickerState = { target: { onPick }, hsv, dragging: null };
    updatePickerUI();
    pickerOverlay.style.display = "flex";
  }

  function closePicker() {
    pickerOverlay.style.display = "none";
    pickerState = { target:null, hsv:{h:0,s:0,v:0}, dragging:null };
  }

  function updatePickerUI() {
    const { h, s, v } = pickerState.hsv;
    satEl.style.setProperty("--picker-hue", `hsl(${h} 100% 50%)`);
    const satRect = satEl.getBoundingClientRect();
    satHandle.style.left = `${s * satRect.width}px`;
    satHandle.style.top = `${(1 - v) * satRect.height}px`;
    const hueRect = hueEl.getBoundingClientRect();
    hueHandle.style.left = `${(h/360) * hueRect.width}px`;
    const hex = hsvToHex(h, s, v);
    previewEl.style.background = hex;
  }

  function handleSatMove(clientX, clientY) {
    const rect = satEl.getBoundingClientRect();
    let x = Math.min(Math.max(clientX - rect.left, 0), rect.width);
    let y = Math.min(Math.max(clientY - rect.top, 0), rect.height);
    pickerState.hsv.s = x / rect.width;
    pickerState.hsv.v = 1 - (y / rect.height);
    const hex = hsvToHex(pickerState.hsv.h, pickerState.hsv.s, pickerState.hsv.v);
    applyPickerColor(hex);
    updatePickerUI();
  }

  function handleHueMove(clientX) {
    const rect = hueEl.getBoundingClientRect();
    let x = Math.min(Math.max(clientX - rect.left, 0), rect.width);
    pickerState.hsv.h = (x / rect.width) * 360;
    const hex = hsvToHex(pickerState.hsv.h, pickerState.hsv.s, pickerState.hsv.v);
    applyPickerColor(hex);
    updatePickerUI();
  }

  satEl.addEventListener("mousedown", (ev) => {
    ev.preventDefault();
    pickerState.dragging = "sat";
    handleSatMove(ev.clientX, ev.clientY);
  });
  hueEl.addEventListener("mousedown", (ev) => {
    ev.preventDefault();
    pickerState.dragging = "hue";
    handleHueMove(ev.clientX);
  });
  window.addEventListener("mousemove", (ev) => {
    if (!pickerState.dragging) return;
    if (pickerState.dragging === "sat") handleSatMove(ev.clientX, ev.clientY);
    if (pickerState.dragging === "hue") handleHueMove(ev.clientX);
  });
  window.addEventListener("mouseup", () => { pickerState.dragging = null; });
  pickerClose.addEventListener("click", () => closePicker());
  pickerOverlay.addEventListener("click", (ev) => {
    if (ev.target === pickerOverlay) closePicker();
  });

  // -------- render --------
  function renderTabs() {
    const tabs = $("tabs");
    tabs.innerHTML = "";
    state.attackers.forEach(a => {
      const btn = document.createElement("button");
      btn.className = "tab" + (a.id === state.activeAttackerId ? " active" : "");
      btn.textContent = a.name;
      btn.onclick = () => {
        state.activeAttackerId = a.id;
        if (!a.selectedComboId && a.combos[0]) a.selectedComboId = a.combos[0].id;
        commit();
      };
      tabs.appendChild(btn);
    });
  }

  function renderMoves() {
    const active = getActive();
    $("pageTitle").textContent = `æ”»æ’ƒå´ï¼š${active.name}`;
    const wrap = $("moves");
    wrap.innerHTML = "";
    if (active.moves.length === 0) {
      const empty = document.createElement("div");
      empty.className = "empty";
      empty.textContent = "æŠ€ã‚’è¿½åŠ ã™ã‚‹ã¨ã“ã“ã«ãƒœã‚¿ãƒ³ãŒä¸¦ã³ã¾ã™";
      wrap.appendChild(empty);
    } else {
      active.moves.forEach(m => {
        const btn = document.createElement("button");
        btn.className = "moveBtn";
        btn.style.borderColor = moveColor(m);
        btn.style.color = moveColor(m);
        btn.style.setProperty("--mvcolor", moveColor(m));
        btn.onclick = (ev) => {
          if (ev.target.classList.contains("colorHit")) return;
          addSegmentToSelected(m);
        };

        const colorHit = document.createElement("span");
        colorHit.className = "colorHit";
        colorHit.onclick = (ev) => {
          ev.stopPropagation();
          openPicker(btn, (col) => {
            m.color = col;
            btn.style.borderColor = moveColor(m);
            btn.style.color = moveColor(m);
            btn.style.setProperty("--mvcolor", moveColor(m));
            commit();
          }, moveColor(m));
        };
        btn.appendChild(colorHit);

        const label = document.createElement("span");
        label.textContent = `${m.name}ï¼ˆ${m.dmg}ï¼‰`;
        btn.appendChild(label);

        const edit = document.createElement("span");
        edit.textContent = "âœï¸";
        edit.title = "æŠ€åã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç·¨é›†";
        edit.style.marginLeft = "8px";
        edit.style.cursor = "pointer";
        edit.onclick = (ev) => {
          ev.stopPropagation();
          const newName = prompt("æŠ€åã‚’ç·¨é›†", m.name);
          if (newName === null) return;
          const newDmgStr = prompt("ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç·¨é›†", String(m.dmg));
          if (newDmgStr === null) return;
          const newDmg = Number(newDmgStr);
          if (Number.isNaN(newDmg)) return;
          m.name = newName.trim() || m.name;
          m.dmg = newDmg;
          commit();
        };
        btn.appendChild(edit);

        const del = document.createElement("span");
        del.textContent = "âœ–";
        del.title = "æŠ€ã‚’å‰Šé™¤";
        del.style.marginLeft = "6px";
        del.style.cursor = "pointer";
        del.onclick = (ev) => {
          ev.stopPropagation();
          active.moves = active.moves.filter(x => x.id !== m.id);
          commit();
        };
        btn.appendChild(del);

        wrap.appendChild(btn);
      });
    }

    const legend = $("legend");
    legend.innerHTML = "";
  }

  function renderCombos() {
    const active = getActive();
    const wrap = $("combos");
    wrap.innerHTML = "";

    if (active.combos.length === 0) {
      const empty = document.createElement("div");
      empty.className = "empty";
      empty.textContent = "çµ„ã¿åˆã‚ã›ãŒã‚ã‚Šã¾ã›ã‚“ã€‚è¿½åŠ ãƒœã‚¿ãƒ³ã§ä½œæˆã—ã¦ãã ã•ã„ã€‚";
      wrap.appendChild(empty);
      return;
    }

    active.combos.forEach((c, idx) => {
      const card = document.createElement("div");
      card.className = "item comboCard" + (c.id === active.selectedComboId ? " selected" : "");
      card.onclick = () => { active.selectedComboId = c.id; commit(); };

      const total = sumCombo(c);
      card.innerHTML = `
        <div class="top">
          <div><strong>${c.name}</strong> <span class="pill">#${idx+1}</span></div>
          <div class="pill">åˆè¨ˆ ${total}</div>
        </div>
        <div class="divider"></div>
        <div class="small">å†…è¨³ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§1ã¤å‰Šé™¤ï¼‰</div>
      `;

      const segWrap = document.createElement("div");
      c.segments.forEach((s, i) => {
        const row = document.createElement("div");
        row.className = "seg";
        row.style.cursor = "pointer";
        row.title = "ã‚¯ãƒªãƒƒã‚¯ã§ã“ã®è¦ç´ ã‚’å‰Šé™¤";
        row.onclick = (ev) => {
          ev.stopPropagation();
          c.segments.splice(i, 1);
          commit();
        };
        row.innerHTML = `
          <span>${s.name}</span>
          <span style="color:${(() => { const mv = active.moves.find(m => m.id === s.moveId); return mv ? moveColor(mv) : colorFor(s.moveId); })()};">+${s.dmg}</span>
        `;
        segWrap.appendChild(row);
      });

      if (c.segments.length === 0) {
        const empty = document.createElement("div");
        empty.className = "small";
        empty.style.marginTop = "8px";
        empty.textContent = "ï¼ˆã¾ã ä½•ã‚‚å…¥ã£ã¦ã„ã¾ã›ã‚“ï¼‰";
        segWrap.appendChild(empty);
      }

      card.appendChild(segWrap);
      wrap.appendChild(card);
    });
  }

  function renderEnemies() {
    const active = getActive();
    const list = $("enemiesList");
    list.innerHTML = "";

    if (!active.enemies.length) {
      const empty = document.createElement("div");
      empty.className = "empty";
      empty.textContent = "ä»®æƒ³æ•µãŒã‚ã‚Šã¾ã›ã‚“ã€‚HPãƒ©ã‚¤ãƒ³ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚";
      list.appendChild(empty);
      return;
    }

    const grouped = active.enemies.reduce((acc, e) => {
      acc[e.hp] = acc[e.hp] || [];
      acc[e.hp].push(e);
      return acc;
    }, {});

    Object.keys(grouped).sort((a,b) => Number(b) - Number(a)).forEach(hpKey => {
      const color = colorFor(String(hpKey));
      const card = document.createElement("div");
      card.className = "groupCard";

      const header = document.createElement("div");
      header.className = "groupHeader";
      const sw = document.createElement("span");
      sw.style.cssText = `display:inline-block;width:14px;height:14px;border-radius:4px;border:1px solid var(--line);background:${color};cursor:pointer;`;
      sw.title = "è‰²ã‚’å¤‰æ›´";
      sw.onclick = (ev) => {
        ev.stopPropagation();
        openPicker(sw, (col) => {
          grouped[hpKey].forEach(e => { e.color = col; });
          renderAll();
          commit();
        }, colorFor(String(hpKey)));
      };
      header.appendChild(sw);
      const hLabel = document.createElement("strong");
      hLabel.textContent = `HP ${hpKey}`;
      header.appendChild(hLabel);
      card.appendChild(header);

      const rows = document.createElement("div");
      rows.className = "groupRows";
      grouped[hpKey].forEach(e => {
        const row = document.createElement("div");
        row.className = "groupRow";
        const label = document.createElement("span");
        label.innerHTML = `${e.name}`;
        const btn = document.createElement("button");
        btn.className = "danger";
        btn.textContent = "å‰Šé™¤";
        btn.onclick = () => {
          active.enemies = active.enemies.filter(x => x.id !== e.id);
          commit();
        };
        row.appendChild(label);
        row.appendChild(btn);
        rows.appendChild(row);
      });
      card.appendChild(rows);
      list.appendChild(card);
    });
  }

  function renderChart() {
    const active = getActive();
    const svg = $("chart");
    svg.innerHTML = "";

    const W = 900, H = 520;
    const pad = { l: 60, r: 20, t: 20, b: 50 };
    const plotW = W - pad.l - pad.r;
    const plotH = H - pad.t - pad.b;

    // pattern cache for negatives
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    svg.appendChild(defs);
    const patternCache = {};
    function patternIdFor(color) {
      if (patternCache[color]) return patternCache[color];
      const pid = `pat-${color.replace(/[^a-zA-Z0-9]/g, "")}-${Math.random().toString(36).slice(2,6)}`;
      const pat = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
      pat.setAttribute("id", pid);
      pat.setAttribute("patternUnits", "userSpaceOnUse");
      pat.setAttribute("width", "8");
      pat.setAttribute("height", "8");
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", "M-2 6 L2 2 L6 -2 M2 10 L10 2 M6 14 L14 6");
      path.setAttribute("stroke", color);
      path.setAttribute("stroke-width", "2");
      pat.appendChild(path);
      defs.appendChild(pat);
      patternCache[color] = pid;
      return pid;
    }

    const totals = active.combos.map(sumCombo);
    const maxTotal = totals.length ? Math.max(...totals) : 0;
    const maxEnemy = active.enemies.length ? Math.max(...active.enemies.map(e => e.hp)) : 0;
    const ymax = niceMax(Math.max(200, maxTotal, maxEnemy));
    const yToPx = (y) => pad.t + plotH - (y / ymax) * plotH;

    // axes
    const axis = document.createElementNS("http://www.w3.org/2000/svg", "path");
    axis.setAttribute("d", `M ${pad.l} ${pad.t} V ${pad.t+plotH} H ${pad.l+plotW}`);
    axis.setAttribute("stroke", "#334155");
    axis.setAttribute("fill", "none");
    axis.setAttribute("stroke-width", "2");
    svg.appendChild(axis);

    // y ticks
    const ticks = 5;
    for (let i=0;i<=ticks;i++) {
      const yVal = (ymax/ticks)*i;
      const y = yToPx(yVal);
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", pad.l);
      line.setAttribute("x2", pad.l+plotW);
      line.setAttribute("y1", y);
      line.setAttribute("y2", y);
      line.setAttribute("stroke", i===0 ? "#334155" : "#1f2a3a");
      line.setAttribute("stroke-width", "1");
      svg.appendChild(line);

      const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
      txt.setAttribute("x", pad.l - 10);
      txt.setAttribute("y", y + 4);
      txt.setAttribute("text-anchor", "end");
      txt.setAttribute("class", "axisText");
      txt.textContent = Math.round(yVal);
      svg.appendChild(txt);
    }

    // bars
    const n = Math.max(active.combos.length, 1);
    const gap = 12;
    const barW = Math.max(18, (plotW - gap*(n+1)) / n);
    const totalTexts = [];
    const xLabels = [];

    active.combos.forEach((c, i) => {
      const x = pad.l + gap + i*(barW + gap);

      const positives = c.segments.filter(s => s.dmg >= 0);
      const negatives = c.segments.filter(s => s.dmg < 0);

      // stacked positives bottom-up
      let accPos = 0;
      positives.forEach(seg => {
        const y0 = yToPx(accPos);
        const y1 = yToPx(accPos + seg.dmg);
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", x);
        rect.setAttribute("y", y1);
        rect.setAttribute("width", barW);
        rect.setAttribute("height", (y0 - y1));
        const move = active.moves.find(m => m.id === seg.moveId);
        rect.setAttribute("fill", move ? moveColor(move) : colorFor(seg.moveId));
        rect.setAttribute("class", "barStroke");
        svg.appendChild(rect);
        accPos += seg.dmg;
      });

      // stacked negatives downward from top of positives
      let accNeg = accPos;
      negatives.forEach(seg => {
        const next = accNeg + seg.dmg; // seg.dmg is negative
        const yTop = yToPx(accNeg);
        const yBot = yToPx(next);
        const base = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        base.setAttribute("x", x);
        base.setAttribute("y", yTop);
        base.setAttribute("width", barW);
        base.setAttribute("height", (yBot - yTop));
        base.setAttribute("fill", "#0b1220");
        base.setAttribute("class", "barStroke");
        svg.appendChild(base);

        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", x);
        rect.setAttribute("y", yTop);
        rect.setAttribute("width", barW);
        rect.setAttribute("height", (yBot - yTop));
        const move = active.moves.find(m => m.id === seg.moveId);
        const col = move ? moveColor(move) : colorFor(seg.moveId);
        rect.setAttribute("fill", `url(#${patternIdFor(col)})`);
        rect.setAttribute("class", "barStroke");
        svg.appendChild(rect);
        accNeg = next;
      });

      // total label
      const total = sumCombo(c);
      const ty = yToPx(total) - 6;
      const tt = document.createElementNS("http://www.w3.org/2000/svg", "text");
      tt.setAttribute("x", x + barW/2);
      tt.setAttribute("y", Math.max(pad.t+12, ty));
      tt.setAttribute("text-anchor", "middle");
      tt.setAttribute("class", "axisText");
      tt.textContent = total ? `${total}` : "";
      totalTexts.push(tt);

      // x label
      const xl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      xl.setAttribute("x", x + barW/2);
      xl.setAttribute("y", pad.t + plotH + 28);
      xl.setAttribute("text-anchor", "middle");
      xl.setAttribute("class", "axisText");
      xl.textContent = c.name;
      xLabels.push(xl);
    });

    // enemy hp lines (draw last to beå‰é¢)
    const placedYs = [];
    [...active.enemies].sort((a,b) => a.hp - b.hp).forEach((e, enemyIdx) => {
      const y = yToPx(e.hp);
      const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
      l.setAttribute("x1", pad.l);
      l.setAttribute("x2", pad.l+plotW);
      l.setAttribute("y1", y);
      l.setAttribute("y2", y);
      l.setAttribute("class", "hpLine");
      l.setAttribute("stroke", enemyColor(e));
      svg.appendChild(l);

      // avoid label overlap by shifting upward if too close
      let labelY = y - 6;
      for (const py of placedYs) {
        if (Math.abs(labelY - py) < 14) labelY = py - 14;
      }
      labelY = Math.max(pad.t + 12, labelY);
      placedYs.push(labelY);

      const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
      t.setAttribute("x", pad.l + 6);
      t.setAttribute("y", labelY);
      t.setAttribute("class", "hpLabel");
      t.setAttribute("fill", enemyColor(e));
      t.setAttribute("stroke", "#0b0f14");
      t.setAttribute("stroke-width", "3");
      t.setAttribute("stroke-linejoin", "round");
      t.textContent = `${e.name} HP${e.hp}`;
      svg.appendChild(t);

      // reach markers on this line for combos that meet/exceed HP
      active.combos.forEach((c, i) => {
        const total = totals[i] || 0;
        const cx = pad.l + gap + i*(barW + gap) + barW/2;
        const half = Math.max(4, barW * 0.25);
        // highlight on the HP line only when reached
        const backLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        backLine.setAttribute("x1", cx - half);
        backLine.setAttribute("x2", cx + half);
        backLine.setAttribute("y1", y);
        backLine.setAttribute("y2", y);
        backLine.setAttribute("stroke", "#0b0f14");
        backLine.setAttribute("stroke-width", 6);
        backLine.setAttribute("stroke-linecap", "round");
        backLine.setAttribute("opacity", total >= e.hp ? "0.85" : "0");
        svg.appendChild(backLine);

        const segLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        segLine.setAttribute("x1", cx - half);
        segLine.setAttribute("x2", cx + half);
        segLine.setAttribute("y1", y);
        segLine.setAttribute("y2", y);
        segLine.setAttribute("stroke", enemyColor(e));
        segLine.setAttribute("stroke-width", 3);
        segLine.setAttribute("stroke-linecap", "round");
        segLine.setAttribute("opacity", total >= e.hp ? "0.95" : "0");
        svg.appendChild(segLine);
      });
    });

    // draw x labels and totals last (forefront)
    xLabels.forEach(el => svg.appendChild(el));
    totalTexts.forEach(el => svg.appendChild(el));
  }

  function renderAll() {
    renderTabs();
    renderMoves();
    renderCombos();
    renderEnemies();
    renderChart();
  }

  // -------- actions --------
  function addSegmentToSelected(move) {
    const active = getActive();
    const combo = active.combos.find(c => c.id === active.selectedComboId);
    if (!combo) return;

    combo.segments.push({
      moveId: move.id,
      name: move.name,
      dmg: Number(move.dmg) || 0
    });
    commit();
  }

  $("addAttackerBtn").onclick = () => {
    const name = $("newAttackerName").value.trim();
    if (!name) return;
    const a = {
      id: crypto.randomUUID(),
      name,
      moves: [],
      combos: [{ id: crypto.randomUUID(), name: "Combo 1", segments: [] }],
      selectedComboId: null,
      enemies: []
    };
    a.selectedComboId = a.combos[0].id;
    state.attackers.push(a);
    state.activeAttackerId = a.id;
    $("newAttackerName").value = "";
    commit();
  };

  $("addMoveBtn").onclick = () => {
    const active = getActive();
    const name = $("moveName").value.trim();
    const dmg = Number($("moveDmg").value);
    if (!name || Number.isNaN(dmg)) return;
    const id = crypto.randomUUID();
    active.moves.push({ id, name, dmg, color: colorFor(id) });
    $("moveName").value = "";
    $("moveDmg").value = "";
    commit();
  };

  $("addComboBtn").onclick = () => {
    const active = getActive();
    const next = active.combos.length + 1;
    const c = { id: crypto.randomUUID(), name: `Combo ${next}`, segments: [] };
    active.combos.push(c);
    active.selectedComboId = c.id;
    commit();
  };

  $("deleteComboBtn").onclick = () => {
    const active = getActive();
    if (!active.selectedComboId) return;
    const idx = active.combos.findIndex(c => c.id === active.selectedComboId);
    if (idx < 0) return;
    active.combos.splice(idx, 1);
    if (active.combos.length === 0) {
      const fallback = { id: crypto.randomUUID(), name: "Combo 1", segments: [] };
      active.combos.push(fallback);
      active.selectedComboId = fallback.id;
    } else {
      active.selectedComboId = active.combos[0]?.id ?? null;
    }
    commit();
  };

  $("addEnemyBtn").onclick = () => {
    const active = getActive();
    const name = $("enemyName").value.trim();
    const hp = Number($("enemyHp").value);
    if (!name || Number.isNaN(hp)) return;
    const id = crypto.randomUUID();
    active.enemies.push({ id, name, hp, color: enemyColor({ hp }) });
    $("enemyName").value = "";
    $("enemyHp").value = "";
    commit();
  };

  $("clearEnemiesBtn").onclick = () => {
    const active = getActive();
    active.enemies = [];
    commit();
  };

  // initial
  persistState();
  renderAll();
</script>
</body>
</html>
