<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Damage Combo Prototype</title>
  <style>
    :root { --bg:#0b0f14; --panel:#111827; --muted:#94a3b8; --text:#e5e7eb; --accent:#60a5fa; --line:#334155; }
    body { margin:0; font-family: "SF Pro Display", "Segoe UI", "Noto Sans JP", system-ui, -apple-system, sans-serif; background:var(--bg); color:var(--text); }
    header { padding:16px 18px; border-bottom:1px solid var(--line); display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0; font-weight:700; letter-spacing:.01em; }
    header .hint { color:var(--muted); font-size:12px; }

    .wrap { display:grid; grid-template-columns: minmax(300px, 360px) 1fr; gap:12px; padding:12px; }
    .panel { background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:12px; }
    .panel h2 { font-size:13px; margin:0 0 10px; color:var(--muted); font-weight:700; letter-spacing:.02em; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    input, select, button {
      background:#0f172a; color:var(--text); border:1px solid var(--line); border-radius:10px;
      padding:9px 10px; font-size:13px;
    }
    input { width: 100%; box-sizing:border-box; }
    button { cursor:pointer; transition: border-color .15s ease, background .15s ease; }
    button.primary { border-color:#2563eb; background:#0b1b3d; }
    button.primary:hover { background:#0e234f; }
    button.danger { border-color:#b91c1c; background:#2a0f15; }
    button.danger:hover { background:#3a1117; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; }
    .tab { padding:8px 10px; border-radius:999px; border:1px solid var(--line); background:#0f172a; cursor:pointer; font-size:13px; }
    .tab.active { border-color:#2563eb; background:#0b1b3d; }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .list { display:flex; flex-direction:column; gap:8px; }
    .item { border:1px solid var(--line); border-radius:12px; padding:10px; background:#0f172a; }
    .item .top { display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .pill { font-size:12px; color:var(--muted); }
    .small { font-size:12px; color:var(--muted); }
    .empty { color:var(--muted); font-size:12px; padding:4px 0; }
    .moves { display:flex; gap:8px; flex-wrap:wrap; }
    .moveBtn { border-style:dashed; padding:8px 10px; }
    .moveBtn:hover { border-color:#64748b; }
    .combos { display:flex; gap:8px; flex-wrap:wrap; }
    .comboCard { min-width: 220px; flex: 1 1 240px; }
    .comboCard.selected { outline:2px solid #2563eb; outline-offset:0; }
    .seg { display:flex; justify-content:space-between; font-size:12px; color:var(--muted); margin-top:6px; }
    .divider { height:1px; background:var(--line); margin:10px 0; }

    /* chart */
    .chartWrap { display:flex; flex-direction:column; gap:10px; }
    .chartHead { display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap; }
    .legend { display:flex; gap:10px; flex-wrap:wrap; color:var(--muted); font-size:12px; }
    .badge { border:1px solid var(--line); border-radius:999px; padding:6px 10px; background:#0f172a; }
    svg { width:100%; height:520px; background:#0b1220; border:1px solid var(--line); border-radius:12px; }
    .axisText { fill:#94a3b8; font-size:11px; }
    .hpLine { stroke-width:1; stroke-dasharray:6 6; opacity:0.95; }
    .hpLabel { font-size:11px; font-weight:700; paint-order: stroke fill; }
    .barStroke { stroke:#0b1220; stroke-width:2; }

    @media (max-width: 899px) {
      header { flex-direction:column; align-items:flex-start; }
      .wrap { grid-template-columns: 1fr; padding:10px; }
      .panel { padding:14px; }
      .grid2 { grid-template-columns: 1fr; }
      .combos { flex-direction:column; }
      .comboCard { width:100%; }
      .chartHead { align-items:flex-start; }
      svg { height:420px; }
    }
  </style>
</head>
<body>
<header>
  <h1>ãƒ€ãƒ¡ãƒ¼ã‚¸çµ„ã¿åˆã‚ã›ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ—ï¼ˆå¼±ç‚¹ãƒ»æŠµæŠ—åŠ›ãƒ»ç‰¹æ€§ãªã—ï¼‰</h1>
  <div class="hint">æŠ€ã‚’ç™»éŒ² â†’ çµ„ã¿åˆã‚ã›ã‚’è¿½åŠ  â†’ æŠ€ãƒœã‚¿ãƒ³ã§ç©ã¿ä¸Šã’ / ä»®æƒ³æ•µã®HPãƒ©ã‚¤ãƒ³è¿½åŠ </div>
</header>

<div class="wrap">
  <aside class="panel">
    <h2>æ”»æ’ƒã™ã‚‹ãƒã‚±ãƒ¢ãƒ³ï¼ˆãƒšãƒ¼ã‚¸ï¼‰</h2>
    <div class="tabs" id="tabs"></div>

    <div class="divider"></div>

    <div class="row">
      <input id="newAttackerName" placeholder="ä¾‹ï¼šNã®ã‚¾ãƒ­ã‚¢ãƒ¼ã‚¯ex" />
      <button class="primary" id="addAttackerBtn">è¿½åŠ </button>
    </div>

    <div class="divider"></div>

    <h2>æŠ€/ãƒ€ãƒ¡ãƒ¼ã‚¸ç™»éŒ²</h2>
    <div class="grid2">
      <div>
        <div class="small">æŠ€å</div>
        <input id="moveName" placeholder="ä¾‹ï¼šãƒ©ãƒ³ãƒšãƒ¼ã‚¸ã‚µãƒ³ãƒ€ãƒ¼" />
      </div>
      <div>
        <div class="small">ãƒ€ãƒ¡ãƒ¼ã‚¸</div>
        <input id="moveDmg" type="number" min="0" placeholder="250" />
      </div>
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="primary" id="addMoveBtn">ã“ã®ãƒšãƒ¼ã‚¸ã«æŠ€ã‚’è¿½åŠ </button>
    </div>

    <div class="divider"></div>

    <h2>ä»®æƒ³æ•µï¼ˆHPãƒ©ã‚¤ãƒ³ï¼‰</h2>
    <div class="grid2">
      <div>
        <div class="small">åå‰</div>
        <input id="enemyName" placeholder="ä¾‹ï¼šæ‚ªãƒªã‚¶ãƒ¼ãƒ‰ãƒ³ex" />
      </div>
      <div>
        <div class="small">HP</div>
        <input id="enemyHp" type="number" min="0" placeholder="330" />
      </div>
    </div>
    <div class="row" style="margin-top:10px;">
      <button class="primary" id="addEnemyBtn">ä»®æƒ³æ•µã«è¿½åŠ </button>
      <button class="danger" id="clearEnemiesBtn">ä»®æƒ³æ•µã‚’å…¨å‰Šé™¤</button>
    </div>
    <div class="divider"></div>
    <h2>ä»®æƒ³æ•µãƒªã‚¹ãƒˆï¼ˆå€‹åˆ¥å‰Šé™¤ï¼‰</h2>
    <div class="list" id="enemiesList"></div>
  </aside>

  <main class="panel chartWrap">
    <div class="chartHead">
      <div>
        <div class="badge" id="pageTitle">â€”</div>
      </div>
      <div class="row">
        <button class="primary" id="addComboBtn">ãƒ€ãƒ¡ãƒ¼ã‚¸ã®çµ„ã¿åˆã‚ã›ã‚’è¿½åŠ </button>
        <button class="danger" id="deleteComboBtn">é¸æŠä¸­ã®çµ„ã¿åˆã‚ã›ã‚’å‰Šé™¤</button>
      </div>
    </div>

    <div class="legend" id="legend"></div>

    <div class="panel" style="padding:12px;">
      <h2>æŠ€ãƒœã‚¿ãƒ³ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é¸æŠä¸­ã®çµ„ã¿åˆã‚ã›ã¸è¿½åŠ ï¼‰</h2>
      <div class="moves" id="moves"></div>
      <div class="small" style="margin-top:6px;">è‰²ã‚¢ã‚¤ã‚³ãƒ³ã¯å‚ç…§ã®ã¿ã€‚âœï¸ã§ç·¨é›†ã€ğŸ—‘ï¸ã§å‰Šé™¤ã€‚</div>
    </div>

    <div class="panel" style="padding:12px;">
      <h2>çµ„ã¿åˆã‚ã›ãƒªã‚¹ãƒˆï¼ˆã‚¯ãƒªãƒƒã‚¯ã§é¸æŠï¼‰</h2>
      <div class="combos" id="combos"></div>
    </div>

    <div>
      <svg id="chart" viewBox="0 0 900 520" preserveAspectRatio="none"></svg>
      <div class="small" style="margin-top:8px;">
        ç¸¦è»¸ï¼ãƒ€ãƒ¡ãƒ¼ã‚¸ / æ¨ªï¼çµ„ã¿åˆã‚ã›ï¼ˆåˆ—ï¼‰ã€‚ç‚¹ç·šï¼ä»®æƒ³æ•µHPï¼ˆè‰²ã¯å„ä»®æƒ³æ•µã«å¯¾å¿œï¼‰ã€‚
      </div>
    </div>
  </main>
</div>

<script>
  // -------- state --------
  const STORAGE_KEY = "pcg-damage-state-v1";

  function createSampleState() {
    const sampleCombo1 = { id: crypto.randomUUID(), name: "Combo 1", segments: [] };
    const sampleCombo2 = { id: crypto.randomUUID(), name: "Combo 2", segments: [] };
    const attackerId = crypto.randomUUID();
    return {
      attackers: [
        {
          id: attackerId,
          name: "ã‚µãƒ³ãƒ—ãƒ«ï¼šNã®ã‚¾ãƒ­ã‚¢ãƒ¼ã‚¯ex",
          moves: [
            { id: crypto.randomUUID(), name: "ãƒ©ãƒ³ãƒšãƒ¼ã‚¸ã‚µãƒ³ãƒ€ãƒ¼", dmg: 250 },
            { id: crypto.randomUUID(), name: "ã‚¤ãƒã‚»ãƒ³ãƒˆãƒ•ãƒ¬ã‚¤ãƒ ", dmg: 170 },
            { id: crypto.randomUUID(), name: "ã²ãã•ã", dmg: 70 },
            { id: crypto.randomUUID(), name: "è£œæ­£ï¼š+40", dmg: 40 },
            { id: crypto.randomUUID(), name: "è£œæ­£ï¼š+50", dmg: 50 },
          ],
          combos: [sampleCombo1, sampleCombo2],
          selectedComboId: sampleCombo1.id,
          enemies: [
            { id: crypto.randomUUID(), name: "æ‚ªãƒªã‚¶ãƒ¼ãƒ‰ãƒ³ex", hp: 330 },
            { id: crypto.randomUUID(), name: "ãƒ‰ãƒ©ãƒ‘ãƒ«ãƒˆex", hp: 320 }
          ]
        }
      ],
      activeAttackerId: attackerId
    };
  }

  function normalizeState(raw) {
    if (!raw || !Array.isArray(raw.attackers) || raw.attackers.length === 0) {
      return createSampleState();
    }
    const attackers = raw.attackers.map((a, idx) => {
      const combos = (Array.isArray(a.combos) && a.combos.length ? a.combos : [{ id: crypto.randomUUID(), name: "Combo 1", segments: [] }]).map((c, ci) => {
        const segments = Array.isArray(c.segments) ? c.segments.map(s => ({
          moveId: s.moveId || crypto.randomUUID(),
          name: s.name || "è£œæ­£/æŠ€",
          dmg: Number(s.dmg) || 0
        })) : [];
        return {
          id: c.id || crypto.randomUUID(),
          name: c.name || `Combo ${ci + 1}`,
          segments
        };
      });
      return {
        id: a.id || crypto.randomUUID(),
        name: a.name || `æ”»æ’ƒå´ ${idx + 1}`,
        moves: Array.isArray(a.moves) ? a.moves.map((m, mi) => ({
          id: m.id || crypto.randomUUID(),
          name: m.name || `æŠ€ ${mi + 1}`,
          dmg: Number(m.dmg) || 0
        })) : [],
        combos,
        selectedComboId: combos.find(c => c.id === a.selectedComboId)?.id || combos[0].id,
        enemies: Array.isArray(a.enemies) ? a.enemies.map((e, ei) => ({
          id: e.id || crypto.randomUUID(),
          name: e.name || `ä»®æƒ³æ•µ ${ei + 1}`,
          hp: Number(e.hp) || 0
        })) : []
      };
    });

    const activeAttackerId = attackers.find(a => a.id === raw.activeAttackerId)?.id || attackers[0].id;
    return { attackers, activeAttackerId };
  }

  function persistState() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    } catch (e) {
      console.warn("ä¿å­˜ã«å¤±æ•—ã—ã¾ã—ãŸ", e);
    }
  }

  function loadState() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      return normalizeState(raw ? JSON.parse(raw) : null);
    } catch (e) {
      console.warn("èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ã‚µãƒ³ãƒ—ãƒ«ã§é–‹å§‹ã—ã¾ã™ã€‚", e);
      return createSampleState();
    }
  }

  let state = loadState();

  // -------- helpers --------
  const $ = (id) => document.getElementById(id);

  function commit() {
    persistState();
    renderAll();
  }

  function getActive() {
    return state.attackers.find(a => a.id === state.activeAttackerId);
  }

  function sumCombo(combo) {
    return combo.segments.reduce((s, seg) => s + seg.dmg, 0);
  }

  function niceMax(val) {
    // round up to nice tick step
    const steps = [50, 100, 150, 200, 250, 300, 400, 500, 600, 800, 1000];
    for (const s of steps) if (val <= s) return s;
    const pow = Math.pow(10, Math.floor(Math.log10(val)));
    return Math.ceil(val / pow) * pow;
  }

  // deterministic-ish color per move id (no libs)
  function hslToHex(h, s, l) {
    s /= 100; l /= 100;
    const f = (n) => {
      const k = (n + h/30) % 12;
      const a = s * Math.min(l, 1 - l);
      const c = l - a * Math.max(-1, Math.min(k - 3, Math.min(9 - k, 1)));
      return Math.round(255 * c);
    };
    const toHex = (v) => v.toString(16).padStart(2, "0");
    return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;
  }
  function colorFor(id) {
    let h = 0;
    for (let i=0;i<id.length;i++) h = (h*31 + id.charCodeAt(i)) >>> 0;
    const hue = h % 360;
    return hslToHex(hue, 60, 42);
  }

  // -------- render --------
  function renderTabs() {
    const tabs = $("tabs");
    tabs.innerHTML = "";
    state.attackers.forEach(a => {
      const btn = document.createElement("button");
      btn.className = "tab" + (a.id === state.activeAttackerId ? " active" : "");
      btn.textContent = a.name;
      btn.onclick = () => {
        state.activeAttackerId = a.id;
        if (!a.selectedComboId && a.combos[0]) a.selectedComboId = a.combos[0].id;
        commit();
      };
      tabs.appendChild(btn);
    });
  }

  function renderMoves() {
    const active = getActive();
    $("pageTitle").textContent = `æ”»æ’ƒå´ï¼š${active.name}`;
    const wrap = $("moves");
    wrap.innerHTML = "";
    if (active.moves.length === 0) {
      const empty = document.createElement("div");
      empty.className = "empty";
      empty.textContent = "æŠ€ã‚’è¿½åŠ ã™ã‚‹ã¨ã“ã“ã«ãƒœã‚¿ãƒ³ãŒä¸¦ã³ã¾ã™";
      wrap.appendChild(empty);
    } else {
      active.moves.forEach(m => {
        const btn = document.createElement("button");
        btn.className = "moveBtn";
        btn.style.borderColor = colorFor(m.id);
        btn.style.color = colorFor(m.id);
        btn.onclick = () => addSegmentToSelected(m);

        const label = document.createElement("span");
        label.textContent = `${m.name}ï¼ˆ${m.dmg}ï¼‰`;
        btn.appendChild(label);

        const edit = document.createElement("span");
        edit.textContent = "âœï¸";
        edit.title = "æŠ€åã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç·¨é›†";
        edit.style.marginLeft = "8px";
        edit.style.cursor = "pointer";
        edit.onclick = (ev) => {
          ev.stopPropagation();
          const newName = prompt("æŠ€åã‚’ç·¨é›†", m.name);
          if (newName === null) return;
          const newDmgStr = prompt("ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ç·¨é›†", String(m.dmg));
          if (newDmgStr === null) return;
          const newDmg = Number(newDmgStr);
          if (Number.isNaN(newDmg)) return;
          m.name = newName.trim() || m.name;
          m.dmg = newDmg;
          commit();
        };
        btn.appendChild(edit);

        const del = document.createElement("span");
        del.textContent = "âœ–";
        del.title = "æŠ€ã‚’å‰Šé™¤";
        del.style.marginLeft = "6px";
        del.style.cursor = "pointer";
        del.onclick = (ev) => {
          ev.stopPropagation();
          active.moves = active.moves.filter(x => x.id !== m.id);
          commit();
        };
        btn.appendChild(del);

        wrap.appendChild(btn);
      });
    }

    const legend = $("legend");
    legend.innerHTML = "";
  }

  function renderCombos() {
    const active = getActive();
    const wrap = $("combos");
    wrap.innerHTML = "";

    if (active.combos.length === 0) {
      const empty = document.createElement("div");
      empty.className = "empty";
      empty.textContent = "çµ„ã¿åˆã‚ã›ãŒã‚ã‚Šã¾ã›ã‚“ã€‚è¿½åŠ ãƒœã‚¿ãƒ³ã§ä½œæˆã—ã¦ãã ã•ã„ã€‚";
      wrap.appendChild(empty);
      return;
    }

    active.combos.forEach((c, idx) => {
      const card = document.createElement("div");
      card.className = "item comboCard" + (c.id === active.selectedComboId ? " selected" : "");
      card.onclick = () => { active.selectedComboId = c.id; commit(); };

      const total = sumCombo(c);
      card.innerHTML = `
        <div class="top">
          <div><strong>${c.name}</strong> <span class="pill">#${idx+1}</span></div>
          <div class="pill">åˆè¨ˆ ${total}</div>
        </div>
        <div class="divider"></div>
        <div class="small">å†…è¨³ï¼ˆã‚¯ãƒªãƒƒã‚¯ã§1ã¤å‰Šé™¤ï¼‰</div>
      `;

      const segWrap = document.createElement("div");
      c.segments.forEach((s, i) => {
        const row = document.createElement("div");
        row.className = "seg";
        row.style.cursor = "pointer";
        row.title = "ã‚¯ãƒªãƒƒã‚¯ã§ã“ã®è¦ç´ ã‚’å‰Šé™¤";
        row.onclick = (ev) => {
          ev.stopPropagation();
          c.segments.splice(i, 1);
          commit();
        };
        row.innerHTML = `
          <span>${s.name}</span>
          <span style="color:${colorFor(s.moveId)};">+${s.dmg}</span>
        `;
        segWrap.appendChild(row);
      });

      if (c.segments.length === 0) {
        const empty = document.createElement("div");
        empty.className = "small";
        empty.style.marginTop = "8px";
        empty.textContent = "ï¼ˆã¾ã ä½•ã‚‚å…¥ã£ã¦ã„ã¾ã›ã‚“ï¼‰";
        segWrap.appendChild(empty);
      }

      card.appendChild(segWrap);
      wrap.appendChild(card);
    });
  }

  function renderEnemies() {
    const active = getActive();
    const list = $("enemiesList");
    list.innerHTML = "";

    if (!active.enemies.length) {
      const empty = document.createElement("div");
      empty.className = "empty";
      empty.textContent = "ä»®æƒ³æ•µãŒã‚ã‚Šã¾ã›ã‚“ã€‚HPãƒ©ã‚¤ãƒ³ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚";
      list.appendChild(empty);
      return;
    }

    active.enemies.forEach(e => {
      const item = document.createElement("div");
      item.className = "item";
      item.style.display = "flex";
      item.style.justifyContent = "space-between";
      item.style.alignItems = "center";
      const left = document.createElement("div");
      const label = document.createElement("span");
      label.innerHTML = `<strong>${e.name}</strong> <span class="pill">HP ${e.hp}</span>`;
      left.appendChild(label);

      const btn = document.createElement("button");
      btn.className = "danger";
      btn.textContent = "å‰Šé™¤";
      btn.onclick = () => {
        active.enemies = active.enemies.filter(x => x.id !== e.id);
        commit();
      };
      item.appendChild(left);
      item.appendChild(btn);
      list.appendChild(item);
    });
  }

  function renderChart() {
    const active = getActive();
    const svg = $("chart");
    svg.innerHTML = "";

    const W = 900, H = 520;
    const pad = { l: 60, r: 20, t: 20, b: 50 };
    const plotW = W - pad.l - pad.r;
    const plotH = H - pad.t - pad.b;

    const totals = active.combos.map(sumCombo);
    const maxTotal = totals.length ? Math.max(...totals) : 0;
    const maxEnemy = active.enemies.length ? Math.max(...active.enemies.map(e => e.hp)) : 0;
    const ymax = niceMax(Math.max(200, maxTotal, maxEnemy));
    const yToPx = (y) => pad.t + plotH - (y / ymax) * plotH;

    // axes
    const axis = document.createElementNS("http://www.w3.org/2000/svg", "path");
    axis.setAttribute("d", `M ${pad.l} ${pad.t} V ${pad.t+plotH} H ${pad.l+plotW}`);
    axis.setAttribute("stroke", "#334155");
    axis.setAttribute("fill", "none");
    axis.setAttribute("stroke-width", "2");
    svg.appendChild(axis);

    // y ticks
    const ticks = 5;
    for (let i=0;i<=ticks;i++) {
      const yVal = (ymax/ticks)*i;
      const y = yToPx(yVal);
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", pad.l);
      line.setAttribute("x2", pad.l+plotW);
      line.setAttribute("y1", y);
      line.setAttribute("y2", y);
      line.setAttribute("stroke", i===0 ? "#334155" : "#1f2a3a");
      line.setAttribute("stroke-width", "1");
      svg.appendChild(line);

      const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
      txt.setAttribute("x", pad.l - 10);
      txt.setAttribute("y", y + 4);
      txt.setAttribute("text-anchor", "end");
      txt.setAttribute("class", "axisText");
      txt.textContent = Math.round(yVal);
      svg.appendChild(txt);
    }

    // bars
    const n = Math.max(active.combos.length, 1);
    const gap = 16;
    const barW = Math.max(26, (plotW - gap*(n+1)) / n);
    active.combos.forEach((c, i) => {
      const x = pad.l + gap + i*(barW + gap);

      // stacked segments bottom-up
      let acc = 0;
      c.segments.forEach(seg => {
        const y0 = yToPx(acc);
        const y1 = yToPx(acc + seg.dmg);
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", x);
        rect.setAttribute("y", y1);
        rect.setAttribute("width", barW);
        rect.setAttribute("height", (y0 - y1));
        // resolve color: segment may have moveId only; look up move
        const move = active.moves.find(m => m.id === seg.moveId);
        rect.setAttribute("fill", move ? colorFor(move.id) : colorFor(seg.moveId));
        rect.setAttribute("class", "barStroke");
        svg.appendChild(rect);
        acc += seg.dmg;
      });

      // total label
      const total = sumCombo(c);
      const ty = yToPx(total) - 6;
      const tt = document.createElementNS("http://www.w3.org/2000/svg", "text");
      tt.setAttribute("x", x + barW/2);
      tt.setAttribute("y", Math.max(pad.t+12, ty));
      tt.setAttribute("text-anchor", "middle");
      tt.setAttribute("class", "axisText");
      tt.textContent = total ? `${total}` : "";
      svg.appendChild(tt);

      // x label
      const xl = document.createElementNS("http://www.w3.org/2000/svg", "text");
      xl.setAttribute("x", x + barW/2);
      xl.setAttribute("y", pad.t + plotH + 28);
      xl.setAttribute("text-anchor", "middle");
      xl.setAttribute("class", "axisText");
      xl.textContent = c.name;
      svg.appendChild(xl);
    });

    // enemy hp lines (draw last to beå‰é¢)
    const placedYs = [];
    [...active.enemies].sort((a,b) => b.hp - a.hp).forEach((e, enemyIdx) => {
      const y = yToPx(e.hp);
      const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
      l.setAttribute("x1", pad.l);
      l.setAttribute("x2", pad.l+plotW);
      l.setAttribute("y1", y);
      l.setAttribute("y2", y);
      l.setAttribute("class", "hpLine");
      l.setAttribute("stroke", colorFor(e.id));
      svg.appendChild(l);

      // avoid label overlap by shifting upward if too close
      let labelY = y - 6;
      for (const py of placedYs) {
        if (Math.abs(labelY - py) < 14) labelY = py - 14;
      }
      labelY = Math.max(pad.t + 12, labelY);
      placedYs.push(labelY);

      const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
      t.setAttribute("x", pad.l + 6);
      t.setAttribute("y", labelY);
      t.setAttribute("class", "hpLabel");
      t.setAttribute("fill", colorFor(e.id));
      t.setAttribute("stroke", "#0b0f14");
      t.setAttribute("stroke-width", "3");
      t.setAttribute("stroke-linejoin", "round");
      t.textContent = `${e.name} HP${e.hp}`;
      svg.appendChild(t);

      // reach markers on this line for combos that meet/exceed HP
      active.combos.forEach((c, i) => {
        const total = totals[i] || 0;
        if (total < e.hp) return;
        const cx = pad.l + gap + i*(barW + gap) + barW/2;
        // double-stroked highlight on the HP line to indicateåˆ°é”
        const backLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        backLine.setAttribute("x1", cx - barW*0.4);
        backLine.setAttribute("x2", cx + barW*0.4);
        backLine.setAttribute("y1", y);
        backLine.setAttribute("y2", y);
        backLine.setAttribute("stroke", "#0b0f14");
        backLine.setAttribute("stroke-width", 8);
        backLine.setAttribute("stroke-linecap", "round");
        backLine.setAttribute("opacity", "0.85");
        svg.appendChild(backLine);

        const segLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
        segLine.setAttribute("x1", cx - barW*0.4);
        segLine.setAttribute("x2", cx + barW*0.4);
        segLine.setAttribute("y1", y);
        segLine.setAttribute("y2", y);
        segLine.setAttribute("stroke", colorFor(e.id));
        segLine.setAttribute("stroke-width", 5);
        segLine.setAttribute("stroke-linecap", "round");
        segLine.setAttribute("opacity", "0.95");
        svg.appendChild(segLine);
      });
    });
  }

  function renderAll() {
    renderTabs();
    renderMoves();
    renderCombos();
    renderEnemies();
    renderChart();
  }

  // -------- actions --------
  function addSegmentToSelected(move) {
    const active = getActive();
    const combo = active.combos.find(c => c.id === active.selectedComboId);
    if (!combo) return;

    combo.segments.push({
      moveId: move.id,
      name: move.name,
      dmg: Number(move.dmg) || 0
    });
    commit();
  }

  $("addAttackerBtn").onclick = () => {
    const name = $("newAttackerName").value.trim();
    if (!name) return;
    const a = {
      id: crypto.randomUUID(),
      name,
      moves: [],
      combos: [{ id: crypto.randomUUID(), name: "Combo 1", segments: [] }],
      selectedComboId: null,
      enemies: []
    };
    a.selectedComboId = a.combos[0].id;
    state.attackers.push(a);
    state.activeAttackerId = a.id;
    $("newAttackerName").value = "";
    commit();
  };

  $("addMoveBtn").onclick = () => {
    const active = getActive();
    const name = $("moveName").value.trim();
    const dmg = Number($("moveDmg").value);
    if (!name || Number.isNaN(dmg)) return;
    active.moves.push({ id: crypto.randomUUID(), name, dmg });
    $("moveName").value = "";
    $("moveDmg").value = "";
    commit();
  };

  $("addComboBtn").onclick = () => {
    const active = getActive();
    const next = active.combos.length + 1;
    const c = { id: crypto.randomUUID(), name: `Combo ${next}`, segments: [] };
    active.combos.push(c);
    active.selectedComboId = c.id;
    commit();
  };

  $("deleteComboBtn").onclick = () => {
    const active = getActive();
    if (!active.selectedComboId) return;
    const idx = active.combos.findIndex(c => c.id === active.selectedComboId);
    if (idx < 0) return;
    active.combos.splice(idx, 1);
    if (active.combos.length === 0) {
      const fallback = { id: crypto.randomUUID(), name: "Combo 1", segments: [] };
      active.combos.push(fallback);
      active.selectedComboId = fallback.id;
    } else {
      active.selectedComboId = active.combos[0]?.id ?? null;
    }
    commit();
  };

  $("addEnemyBtn").onclick = () => {
    const active = getActive();
    const name = $("enemyName").value.trim();
    const hp = Number($("enemyHp").value);
    if (!name || Number.isNaN(hp)) return;
    const id = crypto.randomUUID();
    active.enemies.push({ id, name, hp });
    $("enemyName").value = "";
    $("enemyHp").value = "";
    commit();
  };

  $("clearEnemiesBtn").onclick = () => {
    const active = getActive();
    active.enemies = [];
    commit();
  };

  // initial
  persistState();
  renderAll();
</script>
</body>
</html>
